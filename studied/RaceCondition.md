# Q. 재고 감소 요청이 한건이 아니라 동시에 여러건 들어올 경우

MySQL InnoDB의 기본 트랜잭션 격리 수준은 `REPEATABLE READ`이다.

REPEATABLE READ 격리 수준에서는 한 트랜잭션이 읽은 데이터를 다른 트랜잭션이 변경하지 못하도록 한다.
즉, 한 트랜잭션이 읽은 데이터는 해당 트랜잭션이 커밋될 때까지 변경되지 않는다. 만약 100건의 재고가 존재하고 여러 스레드가 동시에 
재고를 읽게되면, 각각의 스레드는 100건의 재고가 존재한다는 데이터를 읽게된다. 이때 A 스레드가 재고 감소 연산을 수행하여 재고수는 99개가 되야하지만
B 스레드는 이전에 100건의 재고를 조회한 상태에서 감소 연산을 수행하기 때문에 98건이 아닌 99건의 데이터를 DB에 업데이트 하게 된다.
결국 동시성 이슈, `Race Condition`이 발생하게 된다.

### Isolation Level을 Serializable로 변경하면 동시성 이슈가 해결될까?
더 엄격한 격리 수준을 적용한다면 동시성 이슈가 해결되지 않을까 하는 생각으로 트랜잭션 격리 수준을 `SERIALIZABLE`로 설정하고 테스트를 수행해 보았다.

![serializable](https://i.imgur.com/VmEhvzj.png)

100개의 재고에 100개의 재고 감소 요청을 수행한 테스트 결과, 남은 재고는 0개가 아닌 85개라는 결과가 나왔다. SERIALIZABLE 격리 수준은 
각각의 트랜잭션을 하나씩 수행한다. 문제 원인을 유추해보았을때, 테스트 실패 원인은 동시성 문제가 아니라 `데드락`이 아닐까 생각해보았다.

트랜잭션 격리수준을 SERIALIZABLE로 설정하면 select 쿠리에도 `S lock (Shared lock)`이 적용되어 다른 트랜잭션이 해당 데이터를 수정할 수 없게 된다.
따라서 두 개 이상의 트랜잭션이 동일한 데이터를 읽기 위해 SELECT 쿼리를 실행하면 모두 S lock을 가지게 된다.

이후 첫 번째로 실행된 트랜잭션이 업데이트 작업을 수행하기 위해 `X lock (Exclusive lock)`을 획득하려고 할 때, 이미 다른 트랜잭션에서 가지고 있는
S lock 때문에 데드락이 발생할 수 있다. 즉, 두 개 이상의 트랜잭션이 서로에게 필요한 락을 가지고 있어 상호간에 락을 해제할 수 없는 상황이 발생했기 때문에
테스트가 실패한 것이다.

결국, 트랜잭션 격리수준을 REPEATABLE READ로 유지한 상태에서, 하나의 스레드의 작업이 완료된 후에 다른 스레드가 데이터에 접근하도록 하면 Race Condition을
해결 할 수 있다.
